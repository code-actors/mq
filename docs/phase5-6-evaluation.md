# Phase 5 & 6 Implementation Evaluation

## Summary
- Retry handling lacks the backoff and failure context described in the delivery plan, and the dead-letter queue is implemented as an in-memory queue with no capacity enforcement or integration into queue-level metrics.
- Advanced features such as handler heartbeats, admin APIs, and chaining exist as surface APIs, but the dispatcher never records failure causes and relies on manual signalling, leaving long-running progress tracking and automated wake-ups unvalidated.
- The current automated coverage focuses on unit-style scenarios; targeted end-to-end flows are still needed to validate recovery timing, DLQ replay, heartbeat-driven lease extension, and administrative scaling.

## Phase 5 Findings – Retry, Lease Monitoring, Dead-Letter Routing
1. **Retry backoff and policy enforcement are missing.** `HandlerOptions<T>` exposes backoff configuration, but `QueueManager.RequeueAsync` simply re-enqueues immediately and never calculates a delay or consults handler options, so all retries occur back-to-back.【F:src/MessageQueue.Core/Options/HandlerOptions.cs†L11-L68】【F:src/MessageQueue.Core/QueueManager.cs†L205-L243】
2. **Dead-letter queue ignores configured capacity and persistence.** `DeadLetterQueue` keeps all entries in an unbounded `ConcurrentQueue`, never trimming to `QueueOptions.DeadLetterQueueCapacity` nor restoring/persisting entries beyond opportunistic journal writes, leaving it vulnerable to unbounded growth across process restarts.【F:src/MessageQueue.Core/DeadLetterQueue.cs†L23-L200】【F:src/MessageQueue.Core/Options/QueueOptions.cs†L31-L45】
3. **Queue metrics omit DLQ visibility.** `QueueManager.GetMetricsAsync` still hard-codes `DeadLetterCount = 0`, so operator-facing metrics cannot observe DLQ backlogs and admin APIs cannot report end-to-end health.【F:src/MessageQueue.Core/QueueManager.cs†L272-L285】
4. **Lease monitor performs full scans instead of scheduled expirations.** `LeaseMonitor.CheckExpiredLeasesAsync` materialises every pending message on each run and the polling interval is recomputed by scanning in-memory envelopes, deviating from the min-heap expiry scheduler called out in the plan and increasing load as the queue grows.【F:src/MessageQueue.Core/LeaseMonitor.cs†L56-L113】

## Phase 6 Findings – Handler Chaining, Long-Running Support, Admin APIs
1. **Dispatcher loses failure context for DLQ routing.** `HandlerDispatcher.ProcessMessageAsync` requeues on timeout or handler exceptions but never forwards the exception to `QueueManager.RequeueAsync`, so DLQ entries contain only a generic "Max retries exceeded" reason even when a handler throws.【F:src/MessageQueue.Core/HandlerDispatcher.cs†L304-L359】【F:src/MessageQueue.Core/QueueManager.cs†L205-L243】
2. **No integration between enqueue operations and dispatcher signalling.** The dispatcher requires manual calls to `SignalMessageReady`, yet `QueueManager.EnqueueAsync` never notifies it, leaving workers idle unless tests or callers poke the dispatcher directly.【F:src/MessageQueue.Core/QueueManager.cs†L48-L119】【F:src/MessageQueue.Core/HandlerDispatcher.cs†L82-L118】
3. **Heartbeat lifecycle is incomplete.** `HeartbeatService` tracks progress and extends leases, but nothing removes heartbeat state when messages complete—`QueueManager.AcknowledgeAsync` only updates deduplication indices—so long-running metadata will leak and future lookups report stale activity.【F:src/MessageQueue.Core/HeartbeatService.cs†L19-L124】【F:src/MessageQueue.Core/QueueManager.cs†L126-L151】
4. **Admin metrics flatten DLQ/handler insight.** `QueueAdminApi.GetMetricsAsync` delegates to `QueueManager.GetMetricsAsync`, inheriting the zero DLQ count, and handler metrics aggregate only average execution time without queue latency, so admin endpoints cannot confirm end-to-end SLAs.【F:src/MessageQueue.Core/QueueAdminApi.cs†L41-L89】【F:src/MessageQueue.Core/QueueManager.cs†L272-L285】

## Suggested End-to-End Tests
1. **Retry backoff compliance:** Drive a handler that deterministically fails until the third attempt and assert that dequeue timestamps honour the configured exponential backoff window before the final DLQ hand-off.【F:src/MessageQueue.Core/Options/HandlerOptions.cs†L52-L68】【F:src/MessageQueue.Core/QueueManager.cs†L205-L243】
2. **DLQ accumulation and replay:** Publish messages that exceed max retries, then query admin metrics to verify `DeadLetterCount` growth, inspect failure metadata, replay one entry, and ensure it leaves the DLQ and is reprocessed successfully.【F:src/MessageQueue.Core/DeadLetterQueue.cs†L23-L200】【F:src/MessageQueue.Core/QueueManager.cs†L205-L285】
3. **Heartbeat-driven lease extension:** Run a long-running handler that heartbeats periodically; confirm leases extend without expiry and heartbeat state clears after acknowledgment to avoid stale progress reports.【F:src/MessageQueue.Core/HeartbeatService.cs†L19-L124】【F:src/MessageQueue.Core/QueueManager.cs†L205-L269】
4. **Dispatcher signalling and scaling:** Exercise the dispatcher with real enqueue operations (no manual signalling), assert workers receive messages, and validate that admin-driven scale up/down adjusts concurrency and preserves failure diagnostics in DLQ entries.【F:src/MessageQueue.Core/HandlerDispatcher.cs†L82-L359】【F:src/MessageQueue.Core/QueueAdminApi.cs†L41-L89】
